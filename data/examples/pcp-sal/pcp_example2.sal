pcp_example2 : CONTEXT =
BEGIN

  Semaphore : TYPE = {sem1};

  semSetCtx : CONTEXT = simple_set{Semaphore;};

  NumberOfTasks : NATURAL = 1;

  taskCtx : CONTEXT = pcp_task{Semaphore; NumberOfTasks};

  JobIdx : TYPE = taskCtx!JobIdx;

  task1 : taskCtx!TaskDescriptor = 
                  (# priority := 100, 
                     period := 5, 
                     semaphores := semSetCtx!insert(sem1, semSetCtx!empty_set)
                   #);

  tasks : taskCtx!TaskDescriptors = 
          [ [i : JobIdx]
	          task1];
	
  rsrcCtx : CONTEXT = pcp_rsrc{Semaphore; NumberOfTasks, tasks};

  schCtx : CONTEXT = pcp_scheduler{Semaphore; NumberOfTasks, tasks};

  RSRC : TYPE = rsrcCtx!RSRC;

  Turn : TYPE = schCtx!Turn;

  alloc_step(r : RSRC, j : JobIdx, s : Semaphore) : RSRC =
    rsrcCtx!alloc_step(r,j,s);

  release_step(r : RSRC, j : JobIdx, s : Semaphore) : RSRC =
    rsrcCtx!release_step(r,j,s);

  turn?(t : Turn, j : JobIdx) : BOOLEAN = schCtx!turn?(t, j);

  SIMPLE_PC : TYPE = {l1, l2, l3};

  JobStatus : TYPE = schCtx!JobStatus;

  precedes?(j : JobIdx, k : JobIdx) : BOOLEAN =
    schCtx!precedes?(j,k);

  priority(j : JobIdx) : NATURAL =
    schCtx!priority(j);

  lock(r : RSRC, j : JobIdx, s : Semaphore) : RSRC =
		schCtx!lock(r,j,s);

  unlock(r : RSRC, j : JobIdx, s : Semaphore) : RSRC = 
    schCtx!unlock(r,j,s);

  step(r : RSRC, j : JobIdx) : RSRC =
    schCtx!step(r,j);

  simple_job : MODULE =
	BEGIN
    INPUT turn : Turn
    OUTPUT status : JobStatus
    GLOBAL rsrc : RSRC
    OUTPUT pc : SIMPLE_PC
  INITIALIZATION
    status = schCtx!finished;
    pc = l1
	TRANSITION
    [
       pc = l1 AND turn?(turn',1) --> % execute first step
                                       status' = schCtx!started;
                                       rsrc' = lock(rsrc, 1, sem1);
                                       pc' = l2
       []
       pc = l2 AND turn?(turn',1) --> % execute second step 
                                       rsrc' = step(rsrc, 1);
                                       pc' = l3
       []
       pc = l3 AND turn?(turn',1) --> % execute third step
                                       pc' = l1;
                                       rsrc' = unlock(rsrc, 1, sem1);
                                       status' = schCtx!finished
    ]
	END;

  system : MODULE = 
  schCtx!scheduler ||
  ((WITH OUTPUT job_status : ARRAY JobIdx OF JobStatus
		RENAME status TO job_status[1] 
    IN simple_job)
   []
  schCtx!idle_process);  

END
